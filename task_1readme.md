# Task 1 – Encrypted Messaging App Prototype (RSA + AES)

## 1. Overview

This project implements a minimal **encrypted messaging prototype** using a **hybrid cryptosystem**:

- **RSA** (asymmetric cryptography) is used to encrypt a randomly generated AES key.
- **AES-256** (symmetric cryptography) is used to encrypt the actual message contents.

The system simulates two users:

- **User A** – generates an RSA key pair and owns the **private key**.
- **User B** – wants to send a confidential message to User A using A’s **public key**.

---

## 2. Cryptographic Design

### 2.1 Why Hybrid Encryption?

Pure RSA encryption for long messages is inefficient and has size limitations. Instead, the system combines:

1. **Asymmetric layer (RSA)**  
   - Used **once per message** to encrypt:
     - the randomly generated AES key (and optionally the IV, if not fixed).
   - Ensures the symmetric key is shared securely.

2. **Symmetric layer (AES-256)**  
   - Used to encrypt the **actual message text**.
   - Fast and suitable for arbitrarily long messages.

This approach is known as **hybrid encryption** and is widely used in practice (e.g., TLS, PGP).

---

### 2.2 Data Flow

1. **Key Generation (User A)**  
   - User A generates an **RSA key pair** (e.g., 2048-bit).
   - The **public key** is stored in `public.pem` and can be shared.
   - The **private key** is stored in `private.pem` and must be kept secret.

2. **Message Encryption (User B)**  
   - User B writes a plaintext message into `message.txt`.
   - The program:
     1. Reads `message.txt` as bytes.
     2. Generates a random **AES-256 key** (32 bytes) and an **IV** (e.g., 16 bytes for AES-CBC).
     3. Encrypts the message using AES (e.g., AES-256-CBC with PKCS#7 padding).
     4. Encrypts the AES key using User A’s **RSA public key** (e.g., RSA-OAEP with SHA-256).
   - Outputs:
     - `encrypted_message.bin` – the AES-encrypted message.
     - `aes_key_encrypted.bin` – the RSA-encrypted AES key (and possibly IV, depending on implementation).

3. **Message Decryption (User A)**  
   - User A receives:
     - `encrypted_message.bin`
     - `aes_key_encrypted.bin`
   - The program:
     1. Loads the RSA **private key** from `private.pem`.
     2. Decrypts the AES key using RSA.
     3. Uses the recovered AES key (and IV) to decrypt `encrypted_message.bin`.
     4. Removes padding and decodes the plaintext.
   - Writes the result to `decrypted_message.txt`.

If everything works correctly, **`decrypted_message.txt` is identical to `message.txt`**.

---

## 3. Files in This Task

- **Code**
  - `task1_messaging.py`  
    Main Python script implementing:
    - RSA key generation
    - Hybrid encryption (RSA + AES)
    - Hybrid decryption

- **Keys**
  - `public.pem` – RSA public key (generated by the script).
  - `private.pem` – RSA private key (generated by the script, kept secret).

- **Messages**
  - `message.txt` – input plaintext message authored by User B.
  - `encrypted_message.bin` – AES-encrypted message.
  - `aes_key_encrypted.bin` – RSA-encrypted AES key (and optionally IV).
  - `decrypted_message.txt` – decrypted message recovered by User A.

> Note: `public.pem` and `private.pem` are generated by the program and are therefore not necessarily included in the repository by default.

---

## 4. How to Run

> The exact commands may vary slightly depending on your implementation, but the typical workflow is:

### 4.1 Install Dependencies

Make sure you have Python 3 installed and install the required cryptography library, for example:

```bash
pip install cryptography

